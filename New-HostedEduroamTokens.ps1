# New-HostedEduroamTokens.ps1
#
# Generates as many tokens as requested and ensures we don't create conflicting usernames, writing them to the
# console. Copy/paste or use output redirection from your shell to send directly to a file, e.g. > foo.txt
# By default will output SQL commands that can be used to add the tokens to a SQL DB such as sqlite.
# Alternatively, -AsUsersFile uses the FreeRADIUS flatfile format, recommended only for testing because flat
# files are only read upon FreeRADIUS startup, making it not very scalable.
#
# The idea is to distribute these tokens to constituent eduroam subscribers who can't run their own IdP for one
# reason or another (e.g. lack of IT staff, Linux VM hosting ability, and/or centralized identity source).
#
# Obviously, you'll need to operate an instance of FreeRADIUS somewhere, and feed it the results of this script.
# We envision a FreeRADIUS container for each constituent in question, under a parent DNS domain indicating
# that we're the party hosting the identities, e.g. @foo.roam.example.org, @bar.roam.example.org, and so forth.
# We could use a single realm to hold everyone (foo123@roam.example.org, bar456@roam.example.org), etc., but the
# reports/stats we get from the upstream NRO (Internet2) would make our constituents appear as a single IdP,
# making it hard for us as an eSO to report usage to our constituents without building more infrastructure.

Param(
  [Parameter(Mandatory = $True)]
  [ValidateNotNullOrEmpty()]
  [String] # Realm for generated users, e.g. 'foo.roam.example.org' will generate users like 'a1b2c3@foo.roam.example.org'
  $Realm,

  [Parameter(Mandatory = $True)]
  [ValidateRange(1,100000)]
  [Int] # Number of users or "tokens" to generate
  $TokenCount,

  [Parameter(Mandatory = $False)]
  [Switch] # Output using FreeRADIUS users flatfile format instead of SQL statements
  $AsUsersFile
)


## This function adapted from (AU:0.4.1:NRP) to avoid publishing internal code
# Returns a human-readable 26-character random string of hexadecimal characters (lowercase) and dashes
function New-RandomString{
Param(
)

  # Generate a unique string by making a GUID, and make it slightly more "random" by including the date, down to milliseconds
  $BaseString = "$([guid]::NewGuid())$([datetime]::Now.ToString('yyyyMMddhhmmssfff'))"

  # Use a StringBuilder; Strings aren't mutable anyway and StringBuilder is easier to work with when hashing below
  $StringBuilder = New-Object System.Text.StringBuilder
  foreach($Byte in [System.Security.Cryptography.HashAlgorithm]::Create("SHA256").ComputeHash([System.Text.Encoding]::UTF8.GetBytes($BaseString))){
    [Void]$StringBuilder.Append($Byte.ToString("x2"))
  }
  $StringBuilder.Remove(26,38) | Out-Null

  # Replace every 7th character with a hyphen for readability
  $StringBuilder[6] = '-'; $StringBuilder[13] = '-'; $StringBuilder[20] = '-'

  $StringBuilder.ToString()
}


#$Tokens = [ordered]@{}
$Tokens = @{}
$Retries = 0

Write-Verbose "Generating $TokenCount FreeRADIUS User entries for @$Realm..."
while($Tokens.Count -lt $TokenCount){
  $Data = New-RandomString
  $Username = $Data.Substring(0,6) # 16^6 possible unique users (~16.7 million)
  if(-not $Tokens.ContainsKey($Username)){
    $Tokens[$Username] = $Data.Substring(14,12) # 16^11 possible unique passwords (~17.6 trillion)
  } else {
    Write-Verbose " Duplicate username '$Username', retrying..." # birthday paradox: more likely the larger the # of tokens requested
    $Retries++
  }
}

# Helpful header for future reference. Comment format differs between SQL (--) and FreeRADIUS plaintext (#).
"$(if($AsUsersFile){"#"}else{"--"}) Tokens generated by New-HostedEduroamTokenFile.ps1 on $([datetime]::Now)"

# I don't normally use .GetEnumerator() for readability, but the results speak for themselves:
#  Measure-Command wrapped around this foreach() written two ways:
#  15k tokens, foreach( $Entry in $Tokens.Keys ) with $Entry[$Key] / $Entry.$Key:    totalseconds: 16.6594548
#  15k tokens, foreach( $Entry in .GetEnumerator() ) with $Entry.Key / $Entry.Value: totalseconds:  0.2752275
foreach($Entry in $Tokens.GetEnumerator()){
  if($AsUsersFile){
    "$($Entry.Key)@$Realm Cleartext-Password := '$($Entry.Value)'"
  } else {
    "INSERT INTO radcheck (username, attribute, op, value) VALUES ('$($Entry.Key)@$Realm', 'Cleartext-Password', ':=', '$($Entry.Value)');"
  }
}

Write-Verbose "Generated $($Tokens.Count) tokens. Retried $Retries times due to username collisions."
